---
title: "Programming Over Time"
date: 2021-09-20
slug: "/programming-over-time"
---

Currently I am reading *Software Engineering at Google*. I have worked almost my entire professional career as Software Engineer and mastered Software Engineering as well as Computer Science at the university. Thus, I was very curious to learn how Google defines my knowledge disciplines, how it distinguishes "software engineering" from "programming" or "computer science".

The terms "software engineering" and "programming" are often used interchangeably, but they have different implications. To quote Titus Winters from Google "University students tend to study computer science and get jobs writing code as programmers". This is exactly what I have observed over several years. The term "software engineering" implies the application of some theoretical knowledge to build something real and precise.

At Google, "software engineering" is called "time-integrated programming".  Time adds an important dimension to programming. Cubes are not squares. Software engineering is not programming.

The effect of time on a programme becomes clear when you ask: "What is the expected lifetime of your code?" Short-lived systems are unlikely to be unaffected by time. These systems are "just" a programming problem, just as a cube compressed far enough into one dimension is a square. With long-lived systems, on the other hand, change is important. Over many years, the system will change. Change is inevitable - Agent Smith sends his regards. This realisation is the root of the distinction between "software engineering" and "programming".

One is not more valuable than the other. They are two different problem areas with different constraints, values, and best practices.
